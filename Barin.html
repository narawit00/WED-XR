<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>Brain 3D Model XR - Ultra Edition</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            overflow: hidden; 
            background: radial-gradient(circle at center, #1a1a2a 0%, #0a0a0a 100%);
            font-family: 'Sarabun', sans-serif;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
            touch-action: none;
        }
        canvas { display: block; width: 100vw; height: 100vh; }
        
        /* Loading Screen */
        #loading {
            position: absolute;
            inset: 0;
            background: linear-gradient(135deg, #0f0c29 0%, #302b63 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 5000;
            transition: opacity 0.8s ease;
        }
        .loader-brain {
            width: 100px;
            height: 100px;
            border: 5px solid rgba(200, 150, 150, 0.2);
            border-top-color: #ffaaaa;
            border-radius: 50%;
            animation: brainSpin 1.5s cubic-bezier(0.5, 0.1, 0.5, 0.9) infinite;
            margin-bottom: 25px;
            position: relative;
        }
        .loader-brain::before {
            content: '';
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            bottom: 10px;
            border: 3px solid rgba(200, 150, 150, 0.1);
            border-top-color: #ff8888;
            border-radius: 50%;
            animation: brainSpin 2s linear infinite reverse;
        }
        @keyframes brainSpin {
            0% { transform: rotate(0deg) scale(1); }
            50% { transform: rotate(180deg) scale(1.05); }
            100% { transform: rotate(360deg) scale(1); }
        }
        #loading-text {
            color: #ffaaaa;
            font-size: 1.3rem;
            font-weight: 600;
            text-shadow: 0 2px 10px rgba(0,0,0,0.7);
            text-align: center;
        }
        #loading-detail {
            color: #aaa;
            font-size: 0.9rem;
            margin-top: 8px;
            font-weight: 400;
        }
        
        /* Main UI */
        .main-ui {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            pointer-events: none;
            z-index: 1000;
        }
        .ui-card {
            background: rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 18px;
            padding: 15px 20px;
            color: white;
            pointer-events: auto;
            transition: all 0.3s ease;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }
        .ui-card:hover { background: rgba(255, 255, 255, 0.12); }
        
        #title-section h1 {
            font-size: clamp(1rem, 3vw, 1.5rem);
            font-weight: 700;
            margin-bottom: 5px;
            color: #ffaaaa;
            text-shadow: 0 2px 8px rgba(0,0,0,0.5);
        }
        #status-text {
            font-size: clamp(0.75rem, 2vw, 0.9rem);
            color: #aaa;
        }
        
        /* Controls */
        .control-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 10px 16px;
            margin: 5px 0;
            border-radius: 10px;
            cursor: pointer;
            font-size: 0.85rem;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            display: block;
            width: 100%;
            text-align: left;
            backdrop-filter: blur(5px);
        }
        .control-btn:hover {
            background: rgba(255, 255, 255, 0.15);
            transform: translateX(5px);
        }
        .control-btn.active {
            background: rgba(255, 100, 100, 0.25);
            border-color: #ff6464;
            color: #ff6464;
        }
        
        /* Info Panel */
        #info-panel {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(120px);
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(15px);
            border: 1px solid rgba(200, 150, 150, 0.3);
            border-radius: 20px;
            padding: 20px 25px;
            max-width: 450px;
            width: 85%;
            color: white;
            pointer-events: none;
            opacity: 0;
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            z-index: 1000;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
        }
        #info-panel.visible {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }
        #info-panel h2 {
            color: #ffaaaa;
            margin-bottom: 10px;
            font-size: clamp(1.1rem, 2.5vw, 1.4rem);
            font-weight: 700;
        }
        #info-panel p {
            font-size: clamp(0.8rem, 2vw, 0.95rem);
            line-height: 1.6;
            color: #eee;
        }
        .marker-counter {
            font-size: 0.75rem;
            color: #ffaaaa;
            margin-top: 8px;
            font-weight: 600;
        }
        
        /* FAB Controls */
        .fab-container {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            z-index: 1000;
            pointer-events: auto;
        }
        .fab {
            width: 60px;
            height: 60px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            color: white;
            font-size: 22px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.25);
        }
        .fab:hover { transform: scale(1.1) rotate(5deg); background: rgba(255, 255, 255, 0.15); }
        .fab.active { background: rgba(255, 100, 100, 0.25); border-color: #ff6464; color: #ff6464; }
        
        /* Instructions Overlay */
        #instructions {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease;
            backdrop-filter: blur(10px);
        }
        #instructions.visible {
            opacity: 1;
            pointer-events: auto;
        }
        .instruction-content {
            max-width: 500px;
            text-align: center;
            padding: 30px;
        }
        .instruction-content h2 {
            font-size: 2rem;
            margin-bottom: 20px;
            color: #ffaaaa;
        }
        .instruction-content p {
            font-size: 1.1rem;
            line-height: 1.7;
            margin: 15px 0;
        }
        .instruction-content button {
            margin-top: 25px;
            padding: 12px 35px;
            background: linear-gradient(135deg, #ffaaaa, #ff8888);
            border: none;
            color: #1a1a1a;
            font-size: 1rem;
            font-weight: 600;
            border-radius: 30px;
            cursor: pointer;
            transition: transform 0.3s ease;
        }
        .instruction-content button:hover { transform: scale(1.05); }
        
        /* Gyro Calibration */
        #gyro-calib-ui {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            color: white;
            padding: 30px;
            border-radius: 20px;
            text-align: center;
            z-index: 2000;
            display: none;
            backdrop-filter: blur(20px);
            border: 1px solid rgba(200, 150, 150, 0.3);
        }
        #gyro-calib-ui h3 { color: #ffaaaa; margin-bottom: 15px; }
        #gyro-calib-ui button {
            margin-top: 15px;
            padding: 10px 30px;
            background: #ff6464;
            border: none;
            color: #0a0a1a;
            border-radius: 20px;
            cursor: pointer;
            font-weight: 600;
        }
        
        /* Responsive */
        @media (max-width: 768px) {
            .main-ui { padding: 15px; }
            .ui-card { padding: 12px 15px; }
            .fab-container { bottom: 15px; right: 15px; }
            .fab { width: 50px; height: 50px; font-size: 18px; }
            #info-panel { max-width: 90%; padding: 15px 20px; }
        }
        
        /* Error Display */
        #error-display {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 0, 0, 0.9);
            color: white;
            padding: 20px;
            border-radius: 10px;
            z-index: 3000;
            display: none;
            max-width: 80%;
            text-align: center;
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Sarabun:wght@400;600;700&display=swap" rel="stylesheet">
</head>
<body>
    <!-- Loading Screen -->
    <div id="loading">
        <div class="loader-brain"></div>
        <div id="loading-text">‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÇ‡∏´‡∏•‡∏î‡πÇ‡∏°‡πÄ‡∏î‡∏•‡∏™‡∏°‡∏≠‡∏á...</div>
        <div id="loading-detail">‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î</div>
    </div>
    
    <!-- Error Display -->
    <div id="error-display"></div>
    
    <!-- Instructions (Lock Screen) -->
    <div id="instructions" class="visible">
        <div class="instruction-content">
            <h2>üß† ‡πÇ‡∏°‡πÄ‡∏î‡∏•‡∏™‡∏°‡∏≠‡∏á 3D - 360¬∞</h2>
            <p><strong>PC:</strong> ‡∏Ñ‡∏•‡∏¥‡∏Å‡∏Ç‡∏ß‡∏≤ + ‡∏•‡∏≤‡∏Å‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏´‡∏°‡∏∏‡∏ô | ‡πÄ‡∏•‡∏∑‡πà‡∏≠‡∏ô‡πÄ‡∏°‡∏≤‡∏™‡πå‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ã‡∏π‡∏°</p>
            <p><strong>‡∏°‡∏∑‡∏≠‡∏ñ‡∏∑‡∏≠:</strong> ‡πÅ‡∏ï‡∏∞‡∏ó‡∏µ‡πà‡∏°‡∏≤‡∏£‡πå‡∏Å‡πÄ‡∏Å‡∏≠‡∏£‡πå | ‡∏Å‡∏î üîÑ ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏ä‡πâ Gyroscope 360¬∞</p>
            <p style="color: #ffaaaa; margin-top: 20px;">‡∏õ‡∏£‡∏±‡∏ö‡∏Ñ‡∏∏‡∏ì‡∏†‡∏≤‡∏û‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥‡∏ï‡∏≤‡∏°‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì</p>
            <button onclick="startExperience()">‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô</button>
        </div>
    </div>
    
    <!-- Gyro Calibration -->
    <div id="gyro-calib-ui">
        <h3>üîÑ ‡πÇ‡∏´‡∏°‡∏î Gyroscope</h3>
        <p>‡∏ß‡∏≤‡∏á‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå‡πÉ‡∏´‡πâ‡∏ï‡∏±‡πâ‡∏á‡∏ï‡∏£‡∏á‡πÅ‡∏•‡πâ‡∏ß‡∏Å‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°</p>
        <button onclick="completeGyroCal()">‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô</button>
    </div>
    
    <!-- Main UI -->
    <div class="main-ui">
        <div id="title-section" class="ui-card">
            <h1>‡πÇ‡∏°‡πÄ‡∏î‡∏•‡∏™‡∏°‡∏≠‡∏á 3D - Ultra</h1>
            <p id="mode-status">‡πÇ‡∏´‡∏°‡∏î‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏°‡∏õ‡∏Å‡∏ï‡∏¥</p>
        </div>
        
        <div id="controls-section" class="ui-card">
            <button class="control-btn" id="gyro-btn" onclick="toggleGyro()">open Gyroscope</button>
            <button class="control-btn" onclick="resetCamera()">Reset view</button>
            <button class="control-btn" onclick="toggleAutoRotate()">Auto rotate</button>
            <button class="control-btn" onclick="showHelp()">Help</button>
        </div>
    </div>
    
    <!-- FAB Controls -->
    <div class="fab-container">
        <div class="fab" id="gyro-fab" onclick="toggleGyro()" title="‡πÄ‡∏õ‡∏¥‡∏î/‡∏õ‡∏¥‡∏î Gyroscope">üîÑ</div>
        <div class="fab" onclick="nextMarker()" title="‡∏à‡∏∏‡∏î‡∏ñ‡∏±‡∏î‡πÑ‡∏õ">‚û°Ô∏è</div>
    </div>
    
    <!-- Info Panel -->
    <div id="info-panel">
        <h2 id="info-title">‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÇ‡∏´‡∏•‡∏î...</h2>
        <p id="info-desc">‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏£‡∏≠‡∏™‡∏±‡∏Å‡∏Ñ‡∏£‡∏π‡πà...</p>
        <div class="marker-counter" id="marker-counter">‡∏à‡∏∏‡∏î‡∏ó‡∏µ‡πà 0/12</div>
    </div>
    
    <script>
        // Global error handler
        window.addEventListener('error', function(e) {
            console.error('Critical Error:', e.error);
            document.getElementById('error-display').innerHTML = 
                `<strong>‚ùå ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î</strong><br>${e.error.message}<br><small>‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏£‡∏µ‡πÄ‡∏ü‡∏£‡∏ä‡∏´‡∏ô‡πâ‡∏≤‡∏à‡∏≠</small>`;
            document.getElementById('error-display').style.display = 'block';
            document.getElementById('loading').style.display = 'none';
        });
    </script>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { SimplexNoise } from 'three/addons/math/SimplexNoise.js';
        
        // ===== GLOBAL VARIABLES =====
        let isLocked = true;
        let currentMarkerIndex = -1;
        let gyroMode = false;
        let gyroAlpha = 0, gyroBeta = 0, gyroGamma = 0;
        let gyroCalibration = { alpha: 0, beta: 0, gamma: 0 };
        let isGyroCalibrated = false;
        let autoRotate = false;
        let scene, camera, renderer, controls, brainGroup, markers = [], markerData = [];
        let animationTimestamp = 0;

        // ===== SCENE SETUP =====
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0a0a);
        scene.fog = new THREE.Fog(0x0a0a0a, 15, 50);
        
        camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 2, 18);
        
        renderer = new THREE.WebGLRenderer({ 
            antialias: true, 
            alpha: true,
            powerPreference: "high-performance"
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, isMobileDevice() ? 1.5 : 2));
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.4;
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        document.body.appendChild(renderer.domElement);
        
        // ===== HIGH-QUALITY LIGHTING SETUP =====
        const lightingConfig = {
            ambient: new THREE.AmbientLight(0xffffff, 0.4),
            mainDirectional: new THREE.DirectionalLight(0xffffff, 2.5),
            rimSpot: new THREE.SpotLight(0xffcccc, 4.5, 60, Math.PI / 4, 0.5),
            fillPoint: new THREE.PointLight(0xff8888, 1.5, 100),
            accentPoint: new THREE.PointLight(0xffaaaa, 1.0, 100)
        };
        
        lightingConfig.mainDirectional.position.set(-8, 12, 8);
        lightingConfig.mainDirectional.castShadow = true;
        lightingConfig.mainDirectional.shadow.mapSize.set(2048, 2048);
        lightingConfig.rimSpot.position.set(0, 0, -25);
        lightingConfig.fillPoint.position.set(8, -3, 5);
        lightingConfig.accentPoint.position.set(-5, 3, 6);
        Object.values(lightingConfig).forEach(light => scene.add(light));
        
        // ===== REALISTIC BRAIN COLOR PALETTE =====
        // üß† ‡∏™‡∏µ‡∏ó‡∏µ‡πà‡∏™‡∏°‡∏à‡∏£‡∏¥‡∏á‡∏ï‡∏≤‡∏°‡πÄ‡∏ô‡∏∑‡πâ‡∏≠‡πÄ‡∏¢‡∏∑‡πà‡∏≠‡∏™‡∏°‡∏≠‡∏á‡∏à‡∏£‡∏¥‡∏á
        const realisticBrainColors = {
            cortexRidge: new THREE.Color(0xE8C4C4),  // ‡∏™‡∏µ‡∏ä‡∏°‡∏û‡∏π‡∏≠‡∏°‡πÄ‡∏ó‡∏≤ (‡∏¢‡∏≠‡∏î‡∏£‡πà‡∏≠‡∏á‡∏™‡∏°‡∏≠‡∏á)
            cortexValley: new THREE.Color(0xB89595), // ‡∏™‡∏µ‡∏ä‡∏°‡∏û‡∏π‡πÄ‡∏Ç‡πâ‡∏° (‡∏Å‡πâ‡∏ô‡∏£‡πà‡∏≠‡∏á‡∏™‡∏°‡∏≠‡∏á)
            cerebellum: new THREE.Color(0xD4A5A5),   // ‡∏™‡∏°‡∏≠‡∏á‡∏ô‡πâ‡∏≠‡∏¢ - ‡∏≠‡∏≠‡∏Å‡πÄ‡∏ó‡∏≤‡∏≠‡∏°‡∏ä‡∏°‡∏û‡∏π
            brainstem: new THREE.Color(0x9B6B6B),    // ‡∏™‡∏°‡∏≠‡∏á‡∏™‡πà‡∏ß‡∏ô‡∏•‡πà‡∏≤‡∏á - ‡∏ô‡πâ‡∏≥‡∏ï‡∏≤‡∏•‡∏≠‡∏°‡πÅ‡∏î‡∏á
            marker: 0xFF3333,                        // ‡∏°‡∏≤‡∏£‡πå‡∏Å‡πÄ‡∏Å‡∏≠‡∏£‡πå‡∏™‡∏µ‡πÅ‡∏î‡∏á‡∏™‡∏î
            markerRing: 0xFF3333,
            connectionLine: 0xE8C4C4
        };
        
        // ===== MATERIAL DEFINITIONS =====
        const brainMaterials = {
            cortex: new THREE.MeshPhysicalMaterial({
                color: realisticBrainColors.cortexRidge,
                roughness: 0.12,
                metalness: 0.02,
                clearcoat: 1.0,
                clearcoatRoughness: 0.03,
                transmission: 0.05,
                thickness: 1.5,
                ior: 1.4,
                side: THREE.DoubleSide
            }),
            cerebellum: new THREE.MeshPhysicalMaterial({
                color: realisticBrainColors.cerebellum,
                roughness: 0.15,
                clearcoat: 0.9,
                side: THREE.DoubleSide
            }),
            brainstem: new THREE.MeshPhysicalMaterial({
                color: realisticBrainColors.brainstem,
                roughness: 0.18,
                clearcoat: 0.7,
                side: THREE.DoubleSide
            }),
            marker: new THREE.MeshBasicMaterial({
                color: realisticBrainColors.marker,
                transparent: true,
                opacity: 0.95
            }),
            markerRing: new THREE.MeshBasicMaterial({
                color: realisticBrainColors.markerRing,
                transparent: true,
                opacity: 0.7
            }),
            connectionLine: new THREE.LineBasicMaterial({
                color: realisticBrainColors.connectionLine,
                transparent: true,
                opacity: 0.6
            })
        };
        
        // ===== PROCEDURAL BRAIN GENERATION PARAMETERS =====
        const brainGenerationParams = {
            vertexResolution: isMobileDevice() ? 220 : 360,
            noiseScale: 2.2,
            displacementStrength: 0.25,
            hemisphereGap: 0.12,
            ridgeColor: realisticBrainColors.cortexRidge.clone().convertSRGBToLinear(),
            valleyColor: realisticBrainColors.cortexValley.clone().convertSRGBToLinear()
        };
        
        const noiseGenerator = new SimplexNoise();
        brainGroup = new THREE.Group();
        
        // ===== BRAIN MESH GENERATION FUNCTIONS =====
        function createCerebrumHemisphere(isRightSide, material) {
            const geometry = new THREE.SphereGeometry(1.2, brainGenerationParams.vertexResolution, brainGenerationParams.vertexResolution);
            const positionAttribute = geometry.attributes.position;
            const vertexCount = positionAttribute.count;
            const vector = new THREE.Vector3();
            const colorArray = new Float32Array(vertexCount * 3);
            const tempColor = new THREE.Color();

            for (let i = 0; i < vertexCount; i++) {
                vector.fromBufferAttribute(positionAttribute, i);
                vector.x *= 0.85; vector.z *= 1.3;
                if (vector.y < -0.3) vector.y = -0.3 + (vector.y + 0.3) * 0.4;
                
                if (isRightSide) {
                    if (vector.x < 0) vector.x *= 0.1;
                    vector.x += brainGenerationParams.hemisphereGap / 2;
                } else {
                    if (vector.x > 0) vector.x *= 0.1;
                    vector.x -= brainGenerationParams.hemisphereGap / 2;
                }

                let noiseX = vector.x * brainGenerationParams.noiseScale;
                let noiseY = vector.y * brainGenerationParams.noiseScale;
                let noiseZ = vector.z * brainGenerationParams.noiseScale;
                
                let warp = noiseGenerator.noise(noiseX, noiseY, noiseZ) * 0.6;
                let noise1 = noiseGenerator.noise(noiseX + warp, noiseY + warp, noiseZ);
                let noise2 = noiseGenerator.noise(noiseX*4, noiseY*4, noiseZ*4) * 0.12;
                
                let noiseValue = noise1 + noise2;
                let ridgeFactor = 1.0 - Math.abs(noiseValue);
                ridgeFactor = Math.pow(ridgeFactor, 1.3);
                
                let distFromMid = Math.abs(isRightSide ? vector.x - 0.06 : vector.x + 0.06);
                if (distFromMid < 0.25) ridgeFactor *= (distFromMid * 4);

                let displacement = ridgeFactor * brainGenerationParams.displacementStrength;
                let normal = vector.clone().normalize();
                if (Math.abs(vector.x) < 0.1) displacement *= 0.2;
                vector.add(normal.multiplyScalar(displacement));

                tempColor.copy(brainGenerationParams.valleyColor).lerp(brainGenerationParams.ridgeColor, ridgeFactor * ridgeFactor);
                colorArray[i*3] = tempColor.r;
                colorArray[i*3+1] = tempColor.g;
                colorArray[i*3+2] = tempColor.b;

                positionAttribute.setXYZ(i, vector.x, vector.y, vector.z);
            }

            geometry.setAttribute('color', new THREE.BufferAttribute(colorArray, 3));
            geometry.computeVertexNormals();
            const mesh = new THREE.Mesh(geometry, material);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            return mesh;
        }

        function createCerebellumSection(material) {
            const geometry = new THREE.SphereGeometry(0.7, brainGenerationParams.vertexResolution, brainGenerationParams.vertexResolution);
            const positionAttribute = geometry.attributes.position;
            const vector = new THREE.Vector3();
            const colorArray = new Float32Array(positionAttribute.count * 3);
            const tempColor = new THREE.Color();

            for(let i = 0; i < positionAttribute.count; i++) {
                vector.fromBufferAttribute(positionAttribute, i);
                vector.y *= 0.6; vector.x *= 1.4;
                let frequency = 35.0;
                let stripePattern = Math.sin(vector.y * frequency + vector.z * 10);
                let displacement = (stripePattern + 1.0) * 0.025;
                vector.add(vector.clone().normalize().multiplyScalar(displacement));
                
                let mixFactor = (stripePattern + 1) / 2;
                tempColor.copy(brainGenerationParams.valleyColor).lerp(brainGenerationParams.ridgeColor, mixFactor);
                colorArray[i*3] = tempColor.r;
                colorArray[i*3+1] = tempColor.g;
                colorArray[i*3+2] = tempColor.b;
                
                positionAttribute.setXYZ(i, vector.x, vector.y, vector.z);
            }
            geometry.setAttribute('color', new THREE.BufferAttribute(colorArray, 3));
            geometry.computeVertexNormals();
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(0, -0.65, -0.9);
            mesh.rotation.x = -0.2;
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            return mesh;
        }

        function createBrainStemSection(material) {
            const geometry = new THREE.CylinderGeometry(0.35, 0.22, 1.8, 64, 20);
            const positionAttribute = geometry.attributes.position;
            const colorArray = new Float32Array(positionAttribute.count * 3);
            const vector = new THREE.Vector3();

            for(let i = 0; i < positionAttribute.count; i++){
                vector.fromBufferAttribute(positionAttribute, i);
                vector.z += Math.pow(vector.y, 2) * 0.1;
                positionAttribute.setXYZ(i, vector.x, vector.y, vector.z);
                colorArray[i*3] = brainGenerationParams.ridgeColor.r;
                colorArray[i*3+1] = brainGenerationParams.ridgeColor.g;
                colorArray[i*3+2] = brainGenerationParams.ridgeColor.b;
            }
            geometry.setAttribute('color', new THREE.BufferAttribute(colorArray, 3));
            geometry.computeVertexNormals();
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(0, -1.4, -0.3);
            mesh.rotation.x = 0.2;
            mesh.receiveShadow = true;
            return mesh;
        }
        
        // ===== BRAIN ASSEMBLY =====
        const leftHemisphere = createCerebrumHemisphere(false, brainMaterials.cortex);
        const rightHemisphere = createCerebrumHemisphere(true, brainMaterials.cortex);
        const cerebellumMesh = createCerebellumSection(brainMaterials.cerebellum);
        const brainstemMesh = createBrainStemSection(brainMaterials.brainstem);
        
        brainGroup.add(leftHemisphere, rightHemisphere, cerebellumMesh, brainstemMesh);
        brainGroup.rotation.x = 0.2;
        brainGroup.scale.setScalar(isMobileDevice() ? 0.85 : 1);
        scene.add(brainGroup);
        
        // ===== MARKER SYSTEM =====
        markerData = [
            { id: 1, name: "‡∏™‡∏°‡∏≠‡∏á‡∏™‡πà‡∏ß‡∏ô‡∏´‡∏ô‡πâ‡∏≤", pos: new THREE.Vector3(0, 1.8, 2.4), desc: "‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏°‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡∏î‡∏™‡∏¥‡∏ô‡πÉ‡∏à ‡∏Å‡∏≤‡∏£‡∏ß‡∏≤‡∏á‡πÅ‡∏ú‡∏ô ‡πÅ‡∏•‡∏∞‡∏ö‡∏∏‡∏Ñ‡∏•‡∏¥‡∏Å‡∏†‡∏≤‡∏û" },
            { id: 2, name: "‡∏™‡∏°‡∏≠‡∏á‡∏™‡πà‡∏ß‡∏ô‡∏Ç‡∏°‡∏±‡∏ö", pos: new THREE.Vector3(-2.8, -0.3, 1.6), desc: "‡∏Ñ‡∏ß‡∏≤‡∏°‡∏à‡∏≥ ‡∏Å‡∏≤‡∏£‡∏£‡∏±‡∏ö‡∏£‡∏π‡πâ‡πÄ‡∏™‡∏µ‡∏¢‡∏á ‡πÅ‡∏•‡∏∞‡∏†‡∏≤‡∏©‡∏≤" },
            { id: 3, name: "‡∏™‡∏°‡∏≠‡∏á‡∏™‡πà‡∏ß‡∏ô‡∏Ñ‡∏≤‡∏á", pos: new THREE.Vector3(2.8, 0.7, 2.0), desc: "‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡∏™‡∏±‡∏°‡∏ú‡∏±‡∏™ ‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡πÅ‡∏•‡∏∞‡∏Å‡∏≤‡∏£‡πÄ‡∏Ñ‡∏•‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏´‡∏ß" },
            { id: 4, name: "‡∏™‡∏°‡∏≠‡∏á‡∏™‡πà‡∏ß‡∏ô‡∏´‡∏•‡∏±‡∏á", pos: new THREE.Vector3(0, 0.7, -2.4), desc: "‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡∏Å‡∏≤‡∏£‡∏°‡∏≠‡∏á‡πÄ‡∏´‡πá‡∏ô" },
            { id: 5, name: "‡∏™‡∏°‡∏≠‡∏á‡∏ô‡πâ‡∏≠‡∏¢", pos: new THREE.Vector3(2.2, -1.4, 0), desc: "‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏°‡∏Å‡∏≤‡∏£‡∏ó‡∏£‡∏á‡∏ï‡∏±‡∏ß‡πÅ‡∏•‡∏∞‡∏õ‡∏£‡∏∞‡∏™‡∏≤‡∏ô‡∏á‡∏≤‡∏ô‡∏Å‡∏•‡πâ‡∏≤‡∏°‡πÄ‡∏ô‡∏∑‡πâ‡∏≠" },
            { id: 6, name: "‡∏™‡∏°‡∏≠‡∏á‡∏™‡πà‡∏ß‡∏ô‡∏•‡πà‡∏≤‡∏á", pos: new THREE.Vector3(0.5, -2.4, 0), desc: "‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏°‡∏Å‡∏≤‡∏£‡∏´‡∏≤‡∏¢‡πÉ‡∏à‡πÅ‡∏•‡∏∞‡∏Å‡∏≤‡∏£‡πÄ‡∏ï‡πâ‡∏ô‡∏Ç‡∏≠‡∏á‡∏´‡∏±‡∏ß‡πÉ‡∏à" },
            { id: 7, name: "‡πÅ‡∏ô‡∏ß‡πÅ‡∏¢‡∏Å‡∏¢‡∏≤‡∏ß", pos: new THREE.Vector3(0, 0.7, 0), desc: "‡∏£‡∏≠‡∏¢‡πÅ‡∏¢‡∏Å‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏ã‡∏µ‡∏Å‡∏™‡∏°‡∏≠‡∏á‡∏ã‡πâ‡∏≤‡∏¢‡πÅ‡∏•‡∏∞‡∏Ç‡∏ß‡∏≤" },
            { id: 8, name: "‡∏•‡∏¥‡πâ‡∏ô‡∏´‡∏ô‡πâ‡∏≤", pos: new THREE.Vector3(-1.8, 1.3, 2.2), desc: "‡∏®‡∏π‡∏ô‡∏¢‡πå‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏°‡∏Å‡∏≤‡∏£‡πÄ‡∏Ñ‡∏•‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏´‡∏ß‡∏Ç‡∏≠‡∏á‡∏Å‡∏•‡πâ‡∏≤‡∏°‡πÄ‡∏ô‡∏∑‡πâ‡∏≠" },
            { id: 9, name: "‡∏•‡∏¥‡πâ‡∏ô‡∏´‡∏•‡∏±‡∏á", pos: new THREE.Vector3(2.1, 1.0, 1.8), desc: "‡∏£‡∏±‡∏ö‡∏™‡∏±‡∏ç‡∏ç‡∏≤‡∏ì‡∏Ñ‡∏ß‡∏≤‡∏°‡∏£‡∏π‡πâ‡∏™‡∏∂‡∏Å‡∏à‡∏≤‡∏Å‡∏ó‡∏±‡πà‡∏ß‡∏£‡πà‡∏≤‡∏á‡∏Å‡∏≤‡∏¢" },
            { id: 10, name: "‡∏£‡πà‡∏≠‡∏á‡∏™‡∏°‡∏≠‡∏á‡∏Å‡∏•‡∏≤‡∏á", pos: new THREE.Vector3(-1.5, -0.6, 1.2), desc: "‡πÅ‡∏ô‡∏ß‡πÅ‡∏¢‡∏Å‡∏ó‡∏µ‡πà‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç‡∏Ç‡∏≠‡∏á‡∏™‡∏°‡∏≠‡∏á" },
            { id: 11, name: "‡∏™‡∏∞‡∏û‡∏≤‡∏ô‡∏™‡∏°‡∏≠‡∏á", pos: new THREE.Vector3(1.0, -1.8, 0.4), desc: "‡∏ó‡∏≤‡∏á‡∏ú‡πà‡∏≤‡∏ô‡πÄ‡∏™‡πâ‡∏ô‡∏õ‡∏£‡∏∞‡∏™‡∏≤‡∏ó‡∏™‡∏π‡πà‡πÑ‡∏Ç‡∏™‡∏±‡∏ô‡∏´‡∏•‡∏±‡∏á" },
            { id: 12, name: "‡∏°‡∏±‡∏ò‡∏ò‡∏∏‡∏•‡∏≤‡∏õ‡∏•‡∏≤‡∏¢", pos: new THREE.Vector3(0.4, -2.8, 0.2), desc: "‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏°‡∏Å‡∏≤‡∏£‡∏´‡∏≤‡∏¢‡πÉ‡∏à‡πÅ‡∏•‡∏∞‡∏Å‡∏≤‡∏£‡πÄ‡∏ï‡πâ‡∏ô‡∏Ç‡∏≠‡∏á‡∏´‡∏±‡∏ß‡πÉ‡∏à" }
        ];
        
        markerData.forEach((data, index) => {
            const markerGeometry = new THREE.SphereGeometry(0.08, 16, 16);
            const markerMesh = new THREE.Mesh(markerGeometry, brainMaterials.marker);
            markerMesh.position.copy(data.pos);
            markerMesh.userData = { id: data.id, index, type: 'marker' };
            
            const ringGeometry = new THREE.TorusGeometry(0.12, 0.02, 8, 16);
            const ringMesh = new THREE.Mesh(ringGeometry, brainMaterials.markerRing);
            ringMesh.position.copy(data.pos);
            
            const surfacePoint = data.pos.clone().multiplyScalar(0.85);
            const lineGeometry = new THREE.BufferGeometry().setFromPoints([data.pos, surfacePoint]);
            const lineMesh = new THREE.Line(lineGeometry, brainMaterials.connectionLine);
            
            const arrowGeometry = new THREE.ConeGeometry(0.04, 0.15, 8);
            const arrowMesh = new THREE.Mesh(arrowGeometry, brainMaterials.marker);
            const arrowPosition = data.pos.clone().multiplyScalar(0.88);
            arrowMesh.position.copy(arrowPosition);
            arrowMesh.lookAt(surfacePoint);
            
            brainGroup.add(markerMesh, ringMesh, lineMesh, arrowMesh);
            markers.push({ mesh: markerMesh, ring: ringMesh, line: lineMesh, arrow: arrowMesh, data });
        });
        
        // ===== CAMERA CONTROLS =====
        controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.08;
        controls.minDistance = 5;
        controls.maxDistance = 35;
        controls.maxPolarAngle = Math.PI * 0.85;
        controls.autoRotate = false;
        controls.autoRotateSpeed = 0.4;
        controls.enabled = false;
        
        // ===== RAYCASTING FOR INTERACTION =====
        const raycaster = new THREE.Raycaster();
        const mouseCoordinates = new THREE.Vector2();
        
        renderer.domElement.addEventListener('click', handleInteraction);
        renderer.domElement.addEventListener('touchstart', handleTouchInteraction);
        
        function handleInteraction(event) {
            if (isLocked || gyroMode) return;
            mouseCoordinates.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouseCoordinates.y = -(event.clientY / window.innerHeight) * 2 + 1;
            checkMarkerInteraction();
        }
        
        function handleTouchInteraction(event) {
            if (isLocked || gyroMode || !event.touches.length) return;
            mouseCoordinates.x = (event.touches[0].clientX / window.innerWidth) * 2 - 1;
            mouseCoordinates.y = -(event.touches[0].clientY / window.innerHeight) * 2 + 1;
            checkMarkerInteraction();
        }
        
        function checkMarkerInteraction() {
            raycaster.setFromCamera(mouseCoordinates, camera);
            const markerMeshes = markers.map(m => m.mesh);
            const intersections = raycaster.intersectObjects(markerMeshes);
            
            if (intersections.length > 0) {
                const targetIndex = intersections[0].object.userData.index;
                selectMarker(targetIndex);
            }
        }
        
        // ===== USER INTERFACE FUNCTIONS =====
        window.startExperience = function() {
            isLocked = false;
            controls.enabled = true;
            document.getElementById('instructions').classList.remove('visible');
            updateModeStatus('‡πÇ‡∏´‡∏°‡∏î‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏°‡∏õ‡∏Å‡∏ï‡∏¥ - ‡πÅ‡∏ï‡∏∞‡∏ó‡∏µ‡πà‡∏°‡∏≤‡∏£‡πå‡∏Å‡πÄ‡∏Å‡∏≠‡∏£‡πå‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏™‡∏≥‡∏£‡∏ß‡∏à');
            selectMarker(0);
        };
        
        window.toggleGyro = async function() {
            if (isLocked) {
                showErrorMessage('‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏Å‡πà‡∏≠‡∏ô');
                return;
            }
            
            if (!gyroMode) {
                if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                    try {
                        const permission = await DeviceOrientationEvent.requestPermission();
                        if (permission !== 'granted') {
                            showErrorMessage('‡∏ï‡πâ‡∏≠‡∏á‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö‡∏≠‡∏ô‡∏∏‡∏ç‡∏≤‡∏ï‡πÄ‡∏Ç‡πâ‡∏≤‡∏ñ‡∏∂‡∏á Gyroscope');
                            return;
                        }
                    } catch { return; }
                }
                
                document.getElementById('gyro-calib-ui').style.display = 'block';
                gyroMode = true;
                controls.enabled = false;
                document.getElementById('gyro-btn').classList.add('active');
                document.getElementById('gyro-fab').classList.add('active');
                updateModeStatus('‡πÇ‡∏´‡∏°‡∏î Gyroscope - ‡∏£‡∏≠‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≤‡∏•‡∏¥‡πÄ‡∏ö‡∏£‡∏ó');
            } else {
                deactivateGyroscope();
            }
        };
        
        window.completeGyroCal = function() {
            document.getElementById('gyro-calib-ui').style.display = 'none';
            isGyroCalibrated = false;
            window.addEventListener('deviceorientation', handleGyroscope, { passive: true });
            showInfoPanel();
            document.getElementById('info-title').textContent = 'üîÑ Gyroscope ‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô';
            document.getElementById('info-desc').textContent = '‡∏´‡∏°‡∏∏‡∏ô‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì‡πÉ‡∏ô‡∏ó‡∏∏‡∏Å‡∏ó‡∏¥‡∏®‡∏ó‡∏≤‡∏á‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏™‡∏≥‡∏£‡∏ß‡∏à 360¬∞';
            updateModeStatus('‡πÇ‡∏´‡∏°‡∏î Gyroscope - ‡∏ï‡∏¥‡∏î‡∏ï‡∏≤‡∏°‡∏Å‡∏≤‡∏£‡πÄ‡∏Ñ‡∏•‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏´‡∏ß');
        };
        
        window.resetCamera = function() {
            if (isLocked) {
                showErrorMessage('‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏Å‡πà‡∏≠‡∏ô');
                return;
            }
            camera.position.set(0, 2, 18);
            camera.lookAt(0, 0, 0);
            brainGroup.rotation.set(0, 0, 0);
            currentMarkerIndex = -1;
            markers.forEach(m => {
                m.mesh.material.opacity = 0.95;
                m.ring.material.opacity = 0.7;
                m.line.material.opacity = 0.6;
                m.arrow.material.opacity = 0.95;
                m.mesh.scale.setScalar(1);
                m.ring.scale.setScalar(1);
            });
            document.getElementById('info-panel').classList.remove('visible');
            updateModeStatus('‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï‡∏°‡∏∏‡∏°‡∏°‡∏≠‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢');
        };
        
        window.toggleAutoRotate = function() {
            if (isLocked) {
                showErrorMessage('‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏Å‡πà‡∏≠‡∏ô');
                return;
            }
            autoRotate = !autoRotate;
            controls.autoRotate = autoRotate;
            const buttonElement = document.querySelector('.control-btn[onclick="toggleAutoRotate()"]');
            if (autoRotate) {
                buttonElement.classList.add('active');
                updateModeStatus('‡∏´‡∏°‡∏∏‡∏ô‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥: ‡πÄ‡∏õ‡∏¥‡∏î');
            } else {
                buttonElement.classList.remove('active');
                updateModeStatus('‡∏´‡∏°‡∏∏‡∏ô‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥: ‡∏õ‡∏¥‡∏î');
            }
        };
        
        window.nextMarker = function() {
            if (isLocked) {
                showErrorMessage('‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏Å‡πà‡∏≠‡∏ô');
                return;
            }
            const newIndex = (currentMarkerIndex + 1) % markerData.length;
            selectMarker(newIndex);
        };
        
        window.showHelp = function() {
            document.getElementById('instructions').classList.add('visible');
        };
        
        // ===== HELPER FUNCTIONS =====
        function selectMarker(index) {
            currentMarkerIndex = index;
            const markerInfo = markerData[index];
            
            document.getElementById('info-title').textContent = `${markerInfo.id}. ${markerInfo.name}`;
            document.getElementById('info-desc').textContent = markerInfo.desc;
            document.getElementById('marker-counter').textContent = `‡∏à‡∏∏‡∏î‡∏ó‡∏µ‡πà ${markerInfo.id}/12`;
            showInfoPanel();
            
            markers.forEach((m, i) => {
                const isSelected = i === index;
                m.mesh.material.opacity = isSelected ? 1 : 0.4;
                m.ring.material.opacity = isSelected ? 0.9 : 0.2;
                m.line.material.opacity = isSelected ? 0.8 : 0.3;
                m.arrow.material.opacity = isSelected ? 1 : 0.4;
                m.mesh.scale.setScalar(isSelected ? 1.3 : 1);
                m.ring.scale.setScalar(isSelected ? 1.3 : 1);
            });
            
            const targetPosition = markerInfo.pos.clone().multiplyScalar(1.85);
            animateCameraToTarget(targetPosition);
        }
        
        function showInfoPanel() {
            document.getElementById('info-panel').classList.add('visible');
            clearTimeout(window.infoPanelTimeout);
            window.infoPanelTimeout = setTimeout(() => {
                document.getElementById('info-panel').classList.remove('visible');
            }, 6000);
        }
        
        function animateCameraToTarget(targetPosition) {
            const startPosition = camera.position.clone();
            const animationStartTime = Date.now();
            const animationDuration = 1200;
            
            function updateAnimation() {
                const elapsedTime = Date.now() - animationStartTime;
                const progress = Math.min(elapsedTime / animationDuration, 1);
                const easedProgress = 1 - Math.pow(1 - progress, 4);
                
                camera.position.lerpVectors(startPosition, targetPosition, easedProgress);
                camera.lookAt(0, 0, 0);
                
                if (progress < 1) requestAnimationFrame(updateAnimation);
            }
            updateAnimation();
        }
        
        function updateModeStatus(statusText) {
            document.getElementById('mode-status').textContent = statusText;
        }
        
        function showErrorMessage(message) {
            const errorDisplay = document.getElementById('error-display');
            errorDisplay.textContent = message;
            errorDisplay.style.display = 'block';
            setTimeout(() => errorDisplay.style.display = 'none', 4000);
        }
        
        function isMobileDevice() {
            return window.innerWidth <= 768 || 
                   /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        }
        
        function deactivateGyroscope() {
            gyroMode = false;
            isGyroCalibrated = false;
            controls.enabled = true;
            window.removeEventListener('deviceorientation', handleGyroscope);
            document.getElementById('gyro-btn').classList.remove('active');
            document.getElementById('gyro-fab').classList.remove('active');
            updateModeStatus('‡πÇ‡∏´‡∏°‡∏î‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏°‡∏õ‡∏Å‡∏ï‡∏¥');
        }
        
        function handleGyroscope(event) {
            if (!gyroMode) return;
            
            if (!isGyroCalibrated) {
                gyroCalibration.alpha = event.alpha || 0;
                gyroCalibration.beta = event.beta || 0;
                gyroCalibration.gamma = event.gamma || 0;
                isGyroCalibrated = true;
                return;
            }
            
            const alphaDelta = (event.alpha || 0) - gyroCalibration.alpha;
            const betaDelta = (event.beta || 0) - gyroCalibration.beta;
            const gammaDelta = (event.gamma || 0) - gyroCalibration.gamma;
            
            const lerpFactor = 0.28;
            gyroAlpha = THREE.MathUtils.lerp(gyroAlpha, THREE.MathUtils.degToRad(alphaDelta), lerpFactor);
            gyroBeta = THREE.MathUtils.lerp(gyroBeta, THREE.MathUtils.degToRad(betaDelta), lerpFactor);
            gyroGamma = THREE.MathUtils.lerp(gyroGamma, THREE.MathUtils.degToRad(gammaDelta), lerpFactor);
            
            brainGroup.rotation.order = 'YXZ';
            brainGroup.rotation.x = -gyroBeta;
            brainGroup.rotation.y = -gyroAlpha;
            brainGroup.rotation.z = gyroGamma * 0.5;
        }
        
        // ===== INITIALIZATION SEQUENCE =====
        try {
            setTimeout(() => {
                document.getElementById('loading').style.opacity = '0';
                setTimeout(() => {
                    document.getElementById('loading').style.display = 'none';
                }, 800);
            }, 2000);
            
            startRenderLoop();
            
        } catch (error) {
            showErrorMessage(`Initialization Error: ${error.message}`);
            console.error('Full Error:', error);
        }
        
        function startRenderLoop(currentTime) {
            requestAnimationFrame(startRenderLoop);
            
            if (currentTime - animationTimestamp < 16.67) return;
            animationTimestamp = currentTime;
            
            markers.forEach((m, i) => {
                if (m.mesh.visible) {
                    const pulseEffect = Math.sin(currentTime * 0.0018 + i * 0.5) * 0.15 + 0.85;
                    m.ring.scale.setScalar(pulseEffect * (m.mesh.scale.x > 1 ? 1.3 : 1));
                    m.ring.lookAt(camera.position);
                }
            });
            
            if (!gyroMode) controls.update();
            renderer.render(scene, camera);
        }
        
        // ===== EVENT LISTENERS =====
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            brainGenerationParams.vertexResolution = isMobileDevice() ? 220 : 360;
        });
        
        renderer.domElement.addEventListener('contextmenu', e => e.preventDefault());
        
    </script>
</body>
</html>